import { NextRequest } from 'next/server';
import { verifyIdToken } from '@/lib/firebase-admin';

const BACKEND_URL = process.env.RAG_BACKEND_URL || "https://mskishan26--litlens-backend-lite-ragservicelite-web-app.modal.run";

const SERVICE_TOKEN = process.env.RAG_BACKEND_SERVICE_TOKEN || "dev-secret-123";

// Generate unique IDs without external dependencies
function generateId(prefix: string = 'msg'): string {
  const timestamp = Date.now();
  const randomStr = Math.random().toString(36).substring(2, 15);

  return `${prefix}_${timestamp}_${randomStr}`;
}

function generateUUID(): string {
  // Use crypto.randomUUID if available (Node 19+), otherwise fallback
  if (typeof crypto !== 'undefined' && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  // Fallback for older environments
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

export async function POST(req: NextRequest) {
  try {
    // --- 1. VERIFY USER AUTHENTICATION (SECURITY) ---
    const authHeader = req.headers.get('authorization');
    const isAnonymous = req.headers.get('x-user-anonymous') || 'false';

    if (!authHeader?.startsWith('Bearer ')) {
      return new Response(
        JSON.stringify({ error: 'Missing or invalid authorization header' }),
        { status: 401, headers: { 'Content-Type': 'application/json' } }
      );
    }

    const idToken = authHeader.split('Bearer ')[1];
    let userId: string;

    try {
      // Verify the Firebase ID token - this is cryptographically secure
      const decodedToken = await verifyIdToken(idToken);
      userId = decodedToken.uid; // This is the VERIFIED Firebase UID

      console.log(`[AUTH] Verified user: ${userId} (${decodedToken.email || 'anonymous'})`);
    } catch (error) {
      console.error('[AUTH] Token verification failed:', error);
      return new Response(
        JSON.stringify({ error: 'Invalid or expired authentication token' }),
        { status: 401, headers: { 'Content-Type': 'application/json' } }
      );
    }

    const body = await req.json();
    const { messages } = body;

    // --- 2. EXTRACT SETTINGS ---
    const url = new URL(req.url);
    const enableHallucinationCheck =
      url.searchParams.get('check') === 'true' ||
      body.enableHallucinationCheck === true;

    const conversationId =
      url.searchParams.get('conv_id') ||
      body.conversationId ||
      `conv_${generateUUID()}`; //we need this and need to ensure that this is being stored in dynamoDB

    // --- 3. PARSE MESSAGE ---
    let question = "";
    if (messages && messages.length > 0) {
      for (let i = messages.length - 1; i >= 0; i--) {
        const m = messages[i];
        if (m.role !== 'user') continue;
        if (typeof m.content === 'string' && m.content.length > 0) {
          question = m.content;
          break;
        }
        if (Array.isArray(m.content)) {
          const text = m.content.filter((p: any) => p.type === 'text').map((p: any) => p.text).join('');
          if (text.length > 0) { question = text; break; }
        }
        if (Array.isArray(m.parts)) {
          const text = m.parts.filter((p: any) => p.type === 'text').map((p: any) => p.text).join('');
          if (text.length > 0) { question = text; break; }
        }
      }
    }

    if (!question) {
      return new Response("Could not find valid text in message", { status: 400 });
    }

    console.log(`[MOCK] Received question: "${question?.slice(0, 50)}..." | HalCheck: ${enableHallucinationCheck} | UserId: ${userId}`);

    // --- 4. CONNECT TO BACKEND ---
    // Ensure we append /query to the base URL
    const baseUrl = BACKEND_URL.endsWith('/') ? BACKEND_URL.slice(0, -1) : BACKEND_URL;
    const response = await fetch(`${baseUrl}/query`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "text/event-stream",
        "X-Service-Token": SERVICE_TOKEN,
        "X-User-Id": userId,
        "X-Conversation-Id": conversationId,
        "X-User-Anonymous": isAnonymous,
      },
      body: JSON.stringify({
        question: question,
        conversation_id: conversationId,
        user_id: userId,
        stream: true,
        enable_hallucination_check: enableHallucinationCheck
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      return new Response(`Backend Error: ${response.status} ${errorText}`, { status: response.status });
    }

    // --- 5. TRANSFORM STREAM ---
    const reader = response.body!.getReader();
    const decoder = new TextDecoder();
    const encoder = new TextEncoder();

    // Use the ID generated by the backend if available, otherwise generate one
    const backendMessageId = response.headers.get('x-message-id');
    const messageId = backendMessageId || generateId();
    const textId = generateId();
    console.log(`Generated messageId: ${messageId}`);
    const stream = new ReadableStream({
      async start(controller) {
        let buffer = '';
        let streamStarted = false;
        let gotFirstToken = false;
        let sources: any[] = [];
        let hallucinationResult: any = null;
        let backendDone = false;

        const sendEvent = (data: object) => {
          controller.enqueue(encoder.encode(`data: ${JSON.stringify(data)}\n\n`));
        };

        const startStream = () => {
          if (!streamStarted) {
            sendEvent({ type: "start", messageId });
            sendEvent({ type: "start-step" });
            sendEvent({ type: "text-start", id: textId });
            streamStarted = true;
          }
        };

        try {
          // Keep reading until backend sends [DONE] or stream ends
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            buffer += decoder.decode(value, { stream: true });
            const lines = buffer.split('\n');
            buffer = lines.pop() || '';

            for (const line of lines) {
              const trimmed = line.trim();
              if (!trimmed || trimmed.startsWith(':')) continue;

              if (trimmed.startsWith('data: ')) {
                const dataStr = trimmed.slice(6);

                // Backend signals completion
                if (dataStr === '[DONE]') {
                  backendDone = true;
                  continue;
                }

                try {
                  const event = JSON.parse(dataStr);

                  // 1. Text Token - stream immediately
                  if (event.type === 'token' && event.content) {
                    if (!gotFirstToken) {
                      gotFirstToken = true;
                      startStream();
                    }
                    sendEvent({ type: "text-delta", id: textId, delta: event.content });
                  }

                  // 2. Context/Sources - store for later
                  else if (event.type === 'context') {
                    sources = event.data || [];
                  }

                  // 3. Hallucination Result - store for later
                  else if (event.type === 'hallucination') {
                    console.log(`[RAG] Hallucination result: ${event.num_grounded}/${event.num_claims} grounded`);
                    hallucinationResult = {
                      grounding_ratio: event.grounding_ratio || 0,
                      num_claims: event.num_claims || 0,
                      num_grounded: event.num_grounded || 0,
                      unsupported_claims: event.unsupported_claims || []
                    };
                  }

                  // 4. Done event from backend - this comes AFTER hallucination
                  else if (event.type === 'done') {
                    backendDone = true;
                  }

                  // 5. Errors
                  else if (event.type === 'error') {
                    if (!streamStarted) startStream();
                    sendEvent({ type: "text-delta", id: textId, delta: `\n\n‚ö†Ô∏è Error: ${event.message}` });
                  }

                  // Ignore: status events

                } catch (e) {
                  // Ignore parse errors
                }
              }
            }
          }

          // --- 6. FINISH THE STREAM (only after backend is done) ---
          if (streamStarted) {

            // Add hallucination result if available
            if (hallucinationResult) {
              const ratio = hallucinationResult.grounding_ratio;
              const percentage = (ratio * 100).toFixed(0);

              // Choose emoji based on grounding ratio
              let emoji = '‚úÖ';
              let status = 'Well-grounded';
              if (ratio < 0.5) {
                emoji = '‚ùå';
                status = 'Poorly grounded';
              } else if (ratio < 0.8) {
                emoji = '‚ö†Ô∏è';
                status = 'Partially grounded';
              }

              const hallucinationText = `\n\n---\n${emoji} **Fact Check:** ${hallucinationResult.num_grounded}/${hallucinationResult.num_claims} claims verified (${percentage}%) - ${status}`;
              sendEvent({ type: "text-delta", id: textId, delta: hallucinationText });

              // Show unsupported claims as bullets if any exist
              if (hallucinationResult.unsupported_claims && hallucinationResult.unsupported_claims.length > 0) {
                const claimsText = `\n\n**‚ö†Ô∏è Unverified claims:**\n${hallucinationResult.unsupported_claims.map((claim: string) => `- ${claim}`).join('\n')}`;
                sendEvent({ type: "text-delta", id: textId, delta: claimsText });
              }
            }

            // Add sources
            if (sources.length > 0) {
              const sourceText = "\n\n---\n**üìö Sources:**\n" + sources.slice(0, 5).map((src, i) => {
                const meta = src.metadata || {};
                let title = meta.title || meta.file_path || `Source ${i + 1}`;
                // Clean up file paths
                if (title.includes('/')) {
                  title = title.split('/').pop()?.replace('.pdf', '').replace(/_/g, ' ') || title;
                }
                const score = src.score ? ` (${(src.score * 100).toFixed(0)}%)` : '';
                return `- ${title}${score}`;
              }).join('\n');

              sendEvent({ type: "text-delta", id: textId, delta: sourceText });
            }

            sendEvent({ type: "text-end", id: textId });
            sendEvent({ type: "finish-step" });
            sendEvent({ type: "finish" });

          } else {
            // No tokens received at all
            startStream();
            sendEvent({ type: "text-delta", id: textId, delta: "No response received from the backend. Please try again." });
            sendEvent({ type: "text-end", id: textId });
            sendEvent({ type: "finish-step" });
            sendEvent({ type: "finish" });
          }

          controller.enqueue(encoder.encode('data: [DONE]\n\n'));

        } catch (err) {
          console.error("[RAG] Stream error:", err);
          if (!streamStarted) startStream();
          sendEvent({ type: "text-delta", id: textId, delta: `\n\nStream error: ${err}` });
          sendEvent({ type: "text-end", id: textId });
          sendEvent({ type: "finish-step" });
          sendEvent({ type: "finish" });
          controller.enqueue(encoder.encode('data: [DONE]\n\n'));
        } finally {
          controller.close();
          reader.releaseLock();
        }
      }
    });

    return new Response(stream, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
        'x-vercel-ai-ui-message-stream': 'v1',
        'x-conversation-id': conversationId,
        'x-user-id': userId,
        'x-message-id': messageId,
      }
    });

  } catch (error: any) {
    console.error("Route Handler Error:", error);
    return new Response(JSON.stringify({ error: error.message }), { status: 500 });
  }
}